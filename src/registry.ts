import type { Modding } from "@flamework/core";
import * as ecs from "@rbxts/jecs";

import { createSignal, type Signal } from "./signal";

export interface Wildcard {}
export interface ChildOf {}

export type Entity<T = unknown> = ecs.Entity<T>;
export type Id<T = unknown> = ecs.Id<T>;
export type Pair<P = undefined, O = undefined> = ecs.Pair<P, O>;
export type Tag = ecs.Tag;

export type ComponentKey<T> = Modding.Generic<T, "id">;
export type PairKey<P, O> = Modding.Many<{
	obj: ComponentKey<O extends defined ? O : Wildcard>;
	pred: ComponentKey<P extends defined ? P : Wildcard>;
}>;

export type ResolveKey<T> = T extends Pair<infer P, infer O> ? PairKey<P, O> : ComponentKey<T>;
export type ResolveKeys<T> = Modding.Many<{
	[K in keyof T]: ResolveKey<T[K]>;
}>;

export type FilterPair<T> = T extends Pair<infer P, unknown> ? P : T;
export type FilterPairs<T> = {
	[K in keyof T]: FilterPair<T[K]>;
};

const components = new Map<string, Entity>();

let registry = new ecs.World();
export function getRegistry(): ecs.World {
	return registry;
}

export const signals = {
	added: new Map<Entity, Signal<[Entity]>>(),
	changed: new Map<Entity, Signal<[Entity, unknown]>>(),
	removed: new Map<Entity, Signal<[Entity]>>(),
};

export function added<T>(id: Entity<T>): Signal<[Entity<T>]> {
	return signals.added.get(id)! as Signal<[Entity<T>]>;
}

export function removed<T>(id: Entity<T>): Signal<[Entity<T>]> {
	return signals.removed.get(id)! as Signal<[Entity<T>]>;
}

export function changed<T>(id: Entity<T>): Signal<[Entity<T>, T]> {
	return signals.changed.get(id)! as Signal<[Entity<T>, T]>;
}

function hookListeners<T>(id: Entity<T>): void {
	const addedSignal = createSignal<[Entity]>();
	const removedSignal = createSignal<[Entity]>();
	const changedSignal = createSignal<[Entity, T]>();
	signals.added.set(id, addedSignal);
	signals.removed.set(id, removedSignal);
	signals.changed.set(id, changedSignal);

	registry.set(id, ecs.OnAdd, entity => {
		addedSignal.fire(entity);
	});
	registry.set(id, ecs.OnRemove, entity => {
		removedSignal.fire(entity);
	});
	registry.set(id, ecs.OnSet, (entity, data) => {
		changedSignal.fire(entity, data as T);
	});
}

/**
 * Registers an existing entity to the component registry.
 *
 * @template T - The type of the component.
 * @param runtimeId - The runtime entity to be registered.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function reserve<T>(runtimeId: Entity<T>, key?: Modding.Generic<T, "id">): void {
	assert(key);
	assert(!components.has(key), `A component with the key "${key}" already exists`);
	components.set(key, runtimeId);
	hookListeners<T>(runtimeId);
}

/**
 * Defines a component that can be added to an entity. Components can either tag
 * an entity (e.g., "this entity is an NPC"), store data for an entity (e.g.,
 * "this entity is located at Vector3.new(10, 20, 30)"), or represent
 * relationships between entities <Pair<P, O>> (e.g., "bob Likes alice") that
 * may also store additional data (e.g., "bob Eats 10 apples").
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key.
 * @returns The component entity ID.
 * @metadata macro
 */
export function component<T>(key?: ComponentKey<T>): Entity<T> {
	assert(key);
	let id = components.get(key) as Entity<T> | undefined;

	if (id === undefined) {
		id = registry.component<T>();
		components.set(key, id);
		hookListeners(id);
	}

	return id;
}

/**
 * Retrieves the ID of a component or a pair relationship.
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key or pair key.
 * @returns The component or pair ID.
 * @metadata macro.
 */
export function getId<T>(key?: ResolveKey<T>): Id<FilterPair<T>> {
	assert(key);

	if (typeIs(key, "table")) {
		const pairKey = key as PairKey<unknown, unknown>;
		const object = component(pairKey.obj);
		const predicate = component(pairKey.pred);

		return ecs.pair(predicate, object);
	}

	return component(key);
}

/**
 * Creates a new entity with the specified components.
 *
 * @template T - The type of the components.
 * @param bundle - The components to add to the entity.
 * @param keys - Flamework autogenerated keys.
 * @returns The created entity.
 * @metadata macro
 */
export function spawn<T extends Array<unknown>>(
	bundle?: FilterPairs<T>,
	keys?: ResolveKeys<T>,
): Tag {
	const entity = registry.entity();

	if (bundle && keys) {
		for (let index = 0; index < keys.size(); index++) {
			const id = getId(keys[index]);
			registry.set(entity, id, bundle[index]);
		}
	}

	return entity;
}

/**
 * Deletes the specified entity and all associated components.
 *
 * @param entity - The entity to delete.
 */
export function despawn(entity: Entity): void {
	registry.delete(entity);
}

/**
 * Adds or updates multiple components for the specified entity.
 *
 * @template T - The type of the components.
 * @param entity - The entity to modify.
 * @param values - The values to set for the components.
 * @param keys - Flamework autogenerated keys.
 * @metadata macro
 */
export function insert<T extends Array<unknown>>(
	entity: Entity,
	values: FilterPairs<T>,
	keys?: ResolveKeys<T>,
): void {
	assert(keys);
	for (let index = 0; index < keys.size(); index++) {
		const id = getId(keys[index]);
		registry.set(entity, id, values[index]);
	}
}

/**
 * Adds a pair relationship with a specific target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair relationship is added.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<FilterPair<T>>,
): void;

/**
 * Adds a fully defined pair to an entity. This is used when both the predicate
 * and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair component is added.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T extends Pair<defined, defined>>(entity: Entity, key?: ResolveKey<T>): void;

/**
 * Adds a component to an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to which the component is added.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T>(entity: Entity, key?: ComponentKey<T>): void;

export function add(entity: Entity, argument1?: unknown, argument2?: unknown): void {
	if (argument2 !== undefined) {
		// Pair<P, _> case: add(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		registry.add(entity, ecs.pair(component(key), object));
	} else {
		// Known component case: add(entity, key)
		const key = argument1 as ResolveKey<unknown>;
		registry.add(entity, getId(key));
	}
}

/**
 * Removes a pair relationship with a specific target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which the pair relationship is removed.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<FilterPair<T>>,
): void;

/**
 * Removes a fully defined pair from an entity. This is used when both the
 * predicate and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which the pair component is removed.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T extends Pair<defined, defined>>(entity: Entity, key?: ResolveKey<T>): void;

/**
 * Removes a component from an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity from which the component is removed.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T>(entity: Entity, key?: ComponentKey<T>): void;

export function remove(entity: Entity, argument1?: unknown, argument2?: unknown): void {
	if (argument2 !== undefined) {
		// Pair<P, _> case: remove(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		registry.remove(entity, ecs.pair(component(key), object));
	} else {
		// Known component case: remove(entity, key)
		const key = argument1 as ResolveKey<unknown>;
		registry.remove(entity, getId(key));
	}
}

/**
 * Sets a value for a pair with a specific runtime target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair relationship is added.
 * @param object - The target entity of the relationship (object of the pair).
 * @param value - The value associated with the pair relationship.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	value: FilterPair<T>,
	key?: ComponentKey<FilterPair<T>>,
): void;

/**
 * Sets a value for a fully defined pair on an entity. This is used when both
 * the predicate and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair component is added.
 * @param value - The value associated with the pair component.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T extends Pair<defined, defined>>(
	entity: Entity,
	value: FilterPair<T>,
	key?: ResolveKey<T>,
): void;

/**
 * Sets a value for a component on an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to which the component is added or updated.
 * @param value - The value associated with the component.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T>(entity: Entity, value: T, key?: ComponentKey<T>): void;

export function set(
	entity: Entity,
	argument1: unknown,
	argument2?: unknown,
	argument3?: unknown,
): void {
	if (argument3 !== undefined) {
		// Pair<P, _> case: set(entity, object, value, key)
		const object = argument1 as Entity;
		const value = argument2;
		const key = argument3 as ComponentKey<unknown>;
		registry.set(entity, ecs.pair(component(key), object), value);
	} else {
		// Known component case: set(entity, value, key)
		const value = argument1;
		const key = argument2 as ResolveKey<unknown>;
		registry.set(entity, getId(key), value);
	}
}

/**
 * Retrieves the value of a pair relationship for a specific entity and target.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which to retrieve the pair relationship.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @returns The value associated with the pair relationship.
 * @metadata macro
 */
export function get<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<FilterPair<T>>,
): FilterPair<T> | undefined;

/**
 * Retrieves the value of a component or pair for a specific entity.
 *
 * @template T - The type of the component or pair.
 * @param entity - The entity from which to retrieve the component or pair.
 * @param key - Flamework autogenerated key.
 * @returns The value associated with the component or pair.
 * @metadata macro
 */
export function get<T>(entity: Entity, key?: ResolveKey<T>): FilterPair<T> | undefined;

export function get(entity: Entity, argument1?: unknown, argument2?: unknown): unknown {
	if (argument2 !== undefined) {
		// Pair<P, _> case: get(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		return registry.get(entity, ecs.pair(component(key), object));
	}

	// Known component case: get(entity, key)
	const key = argument1 as ResolveKey<unknown>;
	return registry.get(entity, getId(key));
}

/**
 * Checks if a pair relationship exists for a specific entity and target.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to check for the pair relationship.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @returns True if the pair relationship exists, false otherwise.
 * @metadata macro
 */
export function has<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<FilterPair<T>>,
): boolean;

/**
 * Checks if a component or pair exists for a specific entity.
 *
 * @template T - The type of the component or pair.
 * @param entity - The entity to check for the component or pair.
 * @param key - Flamework autogenerated key.
 * @returns True if the component or pair exists, false otherwise.
 * @metadata macro
 */
export function has<T>(entity: Entity, key?: ResolveKey<T>): boolean;

export function has(entity: Entity, argument1?: unknown, argument2?: unknown): boolean {
	if (argument2 !== undefined) {
		// Pair<P, _> case: has(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		return registry.has(entity, ecs.pair(component(key), object));
	}

	// Known component case: has(entity, key)
	const key = argument1 as ResolveKey<unknown>;
	return registry.has(entity, getId(key));
}

/**
 * Retrieves the target entity of a relationship involving the specified entity
 * and component.
 *
 * @template T - The type of the component.
 * @param entity - The entity to get the target for.
 * @param key - Flamework autogenerated key.
 * @returns The target entity if a relationship exists, or undefined otherwise.
 * @metadata macro
 */
export function target<T>(entity: Entity, key?: ComponentKey<T>): Entity | undefined {
	const id = component(key);
	return registry.target(entity, id);
}

/**
 * Retrieves the parent entity (target of the ChildOf relationship) for the
 * given entity.
 *
 * @param entity - The entity for which to get the parent.
 * @returns The parent entity, or undefined if no parent exists.
 */
export function parent(entity: Entity): Entity | undefined {
	return target<ChildOf>(entity);
}

/**
 * Creates a pair relationship between a component and an entity.
 *
 * @template P - The type of the predicate component.
 * @template O - The type of the object component.
 * @param object - The object entity.
 * @param predicate - The predicate component key.
 * @returns The pair ID.
 * @metadata macro
 */
export function pair<P>(object: Entity, predicate?: ComponentKey<P>): Pair<P, unknown> {
	const predicateId = component(predicate);
	return ecs.pair(predicateId, object);
}

reserve<Wildcard>(ecs.Wildcard as Entity<Wildcard>);
reserve<ChildOf>(ecs.ChildOf as Entity<ChildOf>);

/**
 * Destroys the current world and all associated entities, and resets the
 * registry to a new world.
 *
 * @note This function should likely only be used for testing purposes.
 */
export function destroy(): void {
	components.clear();
	registry = new ecs.World();
}
