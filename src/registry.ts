import type { Modding } from "@flamework/core";
import * as ecs from "@rbxts/jecs";

import type { Signal } from "./signal";
import { createSignal } from "./signal";

export interface Wrap<T> {
	readonly _flamecs_type: T;
}
export interface Tag extends Wrap<undefined> {}

export interface ChildOf extends Tag {}
export interface Wildcard extends Tag {}
export interface Name extends Wrap<string> {}

export type Id<T = unknown> = ecs.Id<T>;
export type Entity<T = unknown> = ecs.Entity<T>;
export type Pair<P = undefined, O = undefined> = ecs.Pair<P, O>;

export type ExtractPredicate<T> = T extends Pair<infer P, unknown> ? P : T;
export type Unwrap<T> = T extends Wrap<infer Inner> ? Inner : T;

export type ResolveValue<T> = Unwrap<ExtractPredicate<T>>;
export type ResolveValues<T> = { [K in keyof T]: ResolveValue<T[K]> };

export type ComponentKey<T> = Modding.Generic<T, "id">;
export type PairKey<P, O> = Modding.Many<{
	obj: ComponentKey<O extends defined ? O : Wildcard>;
	pred: ComponentKey<P extends defined ? P : Wildcard>;
}>;
export type ResolveKey<T> = T extends Pair<infer P, infer O> ? PairKey<P, O> : ComponentKey<T>;
export type ResolveKeys<T> = Modding.Many<{
	[K in keyof T]: ResolveKey<T[K]>;
}>;

type TrailingUndefined<T extends Array<unknown>> = T extends [...infer Rest, undefined]
	? [...TrailingUndefined<Rest>, undefined?]
	: T;

const components = new Map<string, Entity>();
export const registry = new ecs.World();

export const signals = {
	added: new Map<Entity, Signal<[Entity]>>(),
	changed: new Map<Entity, Signal<[Entity, unknown]>>(),
	removed: new Map<Entity, Signal<[Entity]>>(),
};

/**
 * Returns a signal that fires when a component is added to an entity.
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key for the component.
 * @returns A signal that fires when the component is added to any entity.
 * @metadata macro
 */
export function added<T>(key?: ComponentKey<T>): Signal<[Entity<T>]> {
	const id = component(key);
	return signals.added.get(id)! as Signal<[Entity<T>]>;
}

/**
 * Returns a signal that fires when a component is removed from an entity.
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key for the component.
 * @returns A signal that fires when the component is removed from any entity.
 * @metadata macro
 */
export function removed<T>(key?: ComponentKey<T>): Signal<[Entity<T>]> {
	const id = component(key);
	return signals.removed.get(id)! as Signal<[Entity<T>]>;
}

/**
 * Returns a signal that fires when a component's value changes on an entity.
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key for the component.
 * @returns A signal that fires when the component's value changes on any
 *   entity.
 * @metadata macro
 */
export function changed<T>(key?: ComponentKey<T>): Signal<[Entity<T>, T]> {
	const id = component(key);
	return signals.changed.get(id)! as Signal<[Entity<T>, T]>;
}

function hookListeners(id: Entity): void {
	const addedSignal = createSignal<[Entity]>();
	const removedSignal = createSignal<[Entity]>();
	const changedSignal = createSignal<[Entity, unknown]>();
	signals.added.set(id, addedSignal);
	signals.removed.set(id, removedSignal);
	signals.changed.set(id, changedSignal);

	registry.set(id, ecs.OnAdd, (entity) => {
		addedSignal.fire(entity);
	});
	registry.set(id, ecs.OnRemove, (entity) => {
		removedSignal.fire(entity);
	});
	registry.set(id, ecs.OnChange, (entity, data) => {
		changedSignal.fire(entity, data);
	});
}

/**
 * Registers an existing entity to the component registry.
 *
 * @template T - The type of the component.
 * @param runtimeId - The runtime entity to be registered.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function reserve<T>(runtimeId: Entity<Unwrap<T>>, key?: ComponentKey<T>): void {
	assert(key);
	assert(!components.has(key), `A component with the key "${key}" already exists`);
	components.set(key, runtimeId);
	hookListeners(runtimeId);
}

/**
 * Defines a component that can be added to an entity. Components can either tag
 * an entity (e.g., "this entity is an NPC"), store data for an entity (e.g.,
 * "this entity is located at Vector3.new(10, 20, 30)"), or represent
 * relationships between entities <Pair<P, O>> (e.g., "bob Likes alice") that
 * may also store additional data (e.g., "bob Eats 10 apples").
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key.
 * @returns The component entity ID.
 * @metadata macro
 */
export function component<T>(key?: ComponentKey<T>): Entity<Unwrap<T>> {
	assert(key);
	let id = components.get(key) as Entity<Unwrap<T>> | undefined;

	if (id === undefined) {
		id = registry.component();
		components.set(key, id);
		hookListeners(id);
	}

	return id;
}

/**
 * Retrieves the ID of a component or a pair relationship.
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key or pair key.
 * @returns The component or pair ID.
 * @metadata macro.
 */
export function getId<T>(key?: ResolveKey<T>): Id<ResolveValue<T>> {
	assert(key);

	if (typeIs(key, "table")) {
		const pairKey = key as PairKey<unknown, unknown>;
		const object = component(pairKey.obj);
		const predicate = component(pairKey.pred);

		return ecs.pair(predicate, object) as never;
	}

	return component(key);
}

/**
 * Creates a new empty entity.
 *
 * @returns The created entity.
 * @metadata macro
 */
export function spawn(): ecs.Tag;

/**
 * Creates a new entity with the specified tag components.
 *
 * @template T - The type of the components.
 * @param keys - Flamework autogenerated keys.
 * @returns The created entity.
 * @metadata macro
 */
export function spawn<T extends Array<Tag>>(keys?: ResolveKeys<T>): ecs.Tag;

/**
 * Creates a new entity with the specified components and their values.
 *
 * @template T - The type of the components.
 * @param values - The values to set for the components.
 * @param keys - Flamework autogenerated keys.
 * @returns The created entity.
 * @metadata macro
 */
export function spawn<T extends Array<unknown>>(
	values: TrailingUndefined<ResolveValues<T>>,
	keys?: ResolveKeys<T>,
): ecs.Tag;

export function spawn<T extends Array<unknown>>(argument1?: unknown, argument2?: unknown): ecs.Tag {
	const entity = registry.entity();

	if (argument2 !== undefined) {
		// Spawn with components: spawn(values, keys)
		const values = argument1 as TrailingUndefined<ResolveValues<T>>;
		const keys = argument2 as ResolveKeys<T>;

		for (let index = 0; index < keys.size(); index++) {
			const id = getId(keys[index]);
			const value = values[index];
			if (value !== undefined) {
				registry.set(entity, id, value);
			} else {
				registry.add(entity, id as never);
			}
		}
	} else if (argument1 !== undefined) {
		// Spawn with tags only: spawn(keys)
		const keys = argument1 as ResolveKeys<T>;
		for (const key of keys) {
			registry.add(entity, getId(key) as never);
		}
	}

	return entity;
}

/**
 * Deletes the specified entity and all associated components.
 *
 * @param entity - The entity to delete.
 */
export function despawn(entity: Entity): void {
	registry.delete(entity);
}

/**
 * Adds or updates multiple components for the specified entity.
 *
 * @template T - The type of the components.
 * @param entity - The entity to modify.
 * @param keys - Flamework autogenerated keys.
 * @metadata macro
 */
export function insert<T extends Array<Tag>>(entity: Entity, keys?: ResolveKeys<T>): void;

/**
 * Adds or updates multiple components for the specified entity.
 *
 * @template T - The type of the components.
 * @param entity - The entity to modify.
 * @param values - The values to set for the components.
 * @param keys - Flamework autogenerated keys.
 * @metadata macro
 */
export function insert<T extends Array<unknown>>(
	entity: Entity,
	values: TrailingUndefined<ResolveValues<T>>,
	keys?: ResolveKeys<T>,
): void;

export function insert<T extends Array<unknown>>(
	entity: Entity,
	argument1?: unknown,
	argument2?: unknown,
): void {
	assert(argument1 !== undefined);
	if (argument2 !== undefined) {
		// Insert components: insert(entity, values, keys)
		const values = argument1 as TrailingUndefined<ResolveValues<T>>;
		const keys = argument2 as ResolveKeys<T>;

		for (let index = 0; index < keys.size(); index++) {
			const id = getId(keys[index]);
			const value = values[index];
			if (value !== undefined) {
				registry.set(entity, id, value);
			} else {
				registry.add(entity, id as never);
			}
		}
	} else {
		// Insert tags only: insert(entity, keys)
		const keys = argument1 as ResolveKeys<T>;
		for (const key of keys) {
			registry.add(entity, getId(key) as never);
		}
	}
}

/**
 * Adds a pair relationship with a specific target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair relationship is added.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T extends Pair<Tag>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<ExtractPredicate<T>>,
): void;

/**
 * Adds a fully defined pair to an entity. This is used when both the predicate
 * and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair component is added.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T extends Pair<Tag, defined>>(entity: Entity, key?: ResolveKey<T>): void;

/**
 * Adds a component to an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to which the component is added.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function add<T extends Tag>(entity: Entity, key?: ComponentKey<T>): void;

export function add(entity: Entity, argument1?: unknown, argument2?: unknown): void {
	if (argument2 !== undefined) {
		// Pair<P, _> case: add(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		registry.add(entity, ecs.pair(component(key), object) as never);
	} else {
		// Known component case: add(entity, key)
		const key = argument1 as ResolveKey<unknown>;
		registry.add(entity, getId(key) as never);
	}
}

/**
 * Removes a pair relationship with a specific target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which the pair relationship is removed.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<ExtractPredicate<T>>,
): void;

/**
 * Removes a fully defined pair from an entity. This is used when both the
 * predicate and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which the pair component is removed.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T extends Pair<defined, defined>>(entity: Entity, key?: ResolveKey<T>): void;

/**
 * Removes a component from an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity from which the component is removed.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T>(entity: Entity, key?: ComponentKey<T>): void;

export function remove(entity: Entity, argument1?: unknown, argument2?: unknown): void {
	if (argument2 !== undefined) {
		// Pair<P, _> case: remove(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		registry.remove(entity, ecs.pair(component(key), object));
	} else {
		// Known component case: remove(entity, key)
		const key = argument1 as ResolveKey<unknown>;
		registry.remove(entity, getId(key));
	}
}

/**
 * Sets a value for a pair with a specific runtime target entity.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair relationship is added.
 * @param object - The target entity of the relationship (object of the pair).
 * @param value - The value associated with the pair relationship.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	value: ResolveValue<T>,
	key?: ComponentKey<ExtractPredicate<T>>,
): void;

/**
 * Sets a value for a fully defined pair on an entity. This is used when both
 * the predicate and object of the pair are known at compile-time.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to which the pair component is added.
 * @param value - The value associated with the pair component.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T extends Pair<defined, defined>>(
	entity: Entity,
	value: ResolveValue<T>,
	key?: ResolveKey<T>,
): void;

/**
 * Sets a value for a component on an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to which the component is added or updated.
 * @param value - The value associated with the component.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T>(entity: Entity, value: Unwrap<T>, key?: ComponentKey<T>): void;

export function set(
	entity: Entity,
	argument1: unknown,
	argument2?: unknown,
	argument3?: unknown,
): void {
	if (argument3 !== undefined) {
		// Pair<P, _> case: set(entity, object, value, key)
		const object = argument1 as Entity;
		const value = argument2;
		const key = argument3 as ComponentKey<unknown>;
		registry.set(entity, ecs.pair(component(key), object), value);
	} else {
		// Known component case: set(entity, value, key)
		const value = argument1;
		const key = argument2 as ResolveKey<unknown>;
		registry.set(entity, getId(key), value);
	}
}

/**
 * Retrieves the value of a pair relationship for a specific entity and target.
 *
 * @template T - The type of the pair.
 * @param entity - The entity from which to retrieve the pair relationship.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @returns The value associated with the pair relationship.
 * @metadata macro
 */
export function get<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<ExtractPredicate<T>>,
): ResolveValue<T> | undefined;

/**
 * Retrieves the value of a component or pair for a specific entity.
 *
 * @template T - The type of the component or pair.
 * @param entity - The entity from which to retrieve the component or pair.
 * @param key - Flamework autogenerated key.
 * @returns The value associated with the component or pair.
 * @metadata macro
 */
export function get<T>(entity: Entity, key?: ResolveKey<T>): ResolveValue<T> | undefined;

export function get(entity: Entity, argument1?: unknown, argument2?: unknown): unknown {
	if (argument2 !== undefined) {
		// Pair<P, _> case: get(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		return registry.get(entity, ecs.pair(component(key), object));
	}

	// Known component case: get(entity, key)
	const key = argument1 as ResolveKey<unknown>;
	return registry.get(entity, getId(key));
}

/**
 * Checks if a pair relationship exists for a specific entity and target.
 *
 * @template T - The type of the pair.
 * @param entity - The entity to check for the pair relationship.
 * @param object - The target entity of the relationship (object of the pair).
 * @param key - Flamework autogenerated key.
 * @returns True if the pair relationship exists, false otherwise.
 * @metadata macro
 */
export function has<T extends Pair<defined>>(
	entity: Entity,
	object: Entity,
	key?: ComponentKey<ExtractPredicate<T>>,
): boolean;

/**
 * Checks if a component or pair exists for a specific entity.
 *
 * @template T - The type of the component or pair.
 * @param entity - The entity to check for the component or pair.
 * @param key - Flamework autogenerated key.
 * @returns True if the component or pair exists, false otherwise.
 * @metadata macro
 */
export function has<T>(entity: Entity, key?: ResolveKey<T>): boolean;

export function has(entity: Entity, argument1?: unknown, argument2?: unknown): boolean {
	if (argument2 !== undefined) {
		// Pair<P, _> case: has(entity, object, key)
		const object = argument1 as Entity;
		const key = argument2 as ComponentKey<unknown>;
		return registry.has(entity, ecs.pair(component(key), object));
	}

	// Known component case: has(entity, key)
	const key = argument1 as ResolveKey<unknown>;
	return registry.has(entity, getId(key));
}

/**
 * Retrieves the target entity of a relationship involving the specified entity
 * and component.
 *
 * @template T - The type of the component.
 * @param entity - The entity to get the target for.
 * @param key - Flamework autogenerated key.
 * @returns The target entity if a relationship exists, or undefined otherwise.
 * @metadata macro
 */
export function target<T>(entity: Entity, key?: ComponentKey<T>): Entity | undefined {
	const id = component(key);
	return registry.target(entity, id);
}

/**
 * Retrieves the parent entity (target of the ChildOf relationship) for the
 * given entity.
 *
 * @param entity - The entity for which to get the parent.
 * @returns The parent entity, or undefined if no parent exists.
 */
export function parent(entity: Entity): Entity | undefined {
	return target<ChildOf>(entity);
}

/**
 * Creates a pair relationship between a component and an entity.
 *
 * @template P - The type of the predicate component.
 * @template O - The type of the object component.
 * @param object - The object entity.
 * @param predicate - The predicate component key.
 * @returns The pair ID.
 * @metadata macro
 */
export function pair<P>(object: Entity, predicate?: ComponentKey<P>): Pair<Unwrap<P>, unknown> {
	const predicateId = component(predicate);
	return ecs.pair(predicateId, object);
}

/**
 * Resets the ECS registry to its initial state. This should primarily be used
 * for unit testing to ensure a clean state between tests.
 */
export function reset(): void {
	const temporaryRegistry = new ecs.World();
	for (const [key, value] of pairs(temporaryRegistry)) {
		(registry as unknown as Record<string, unknown>)[key] = value;
	}

	components.clear();
}

reserve<Wildcard>(ecs.Wildcard as ecs.Tag);
reserve<ChildOf>(ecs.ChildOf as ecs.Tag);
